# Feature: Multi-Language UI + RTL Support

**ID:** 015
**Category:** Localization & i18n
**Priority:** Low
**Inspired by:** Handy — 17 UI languages with RTL support (Arabic)
**Status:** Ready for Implementation

## Problem

EnviousWispr's UI is English-only. Non-English-speaking users must navigate an interface they may not fully understand.

## Proposed Solution

Adopt SwiftUI's built-in localization system:
1. Extract all user-facing strings into `.xcstrings` catalog (or `.strings`/`.stringsdict` files)
2. Use `LocalizedStringKey` / `String(localized:)` for all UI text
3. Start with high-value languages: Spanish, French, German, Japanese, Chinese, Korean
4. Add RTL layout support (Arabic, Hebrew) — SwiftUI handles most of this automatically with `.environment(\.layoutDirection, .rightToLeft)`

## Files to Modify

| File | Change |
|------|--------|
| `Package.swift` | Change `exclude: ["Resources"]` to `resources: [.process("Resources")]` |
| `Sources/EnviousWispr/App/AppDelegate.swift` | Wrap all `NSMenuItem` title strings with `String(localized:)` |
| `Sources/EnviousWispr/Pipeline/PipelineState.swift` | Wrap `statusText` computed property with `String(localized:)` |
| `Sources/EnviousWispr/Views/Settings/SettingsView.swift` | Audit `Text()` literals — most already work as `LocalizedStringKey`; fix string interpolations |
| `Sources/EnviousWispr/Views/Main/TranscriptDetailView.swift` | Audit `Text()` and `Label()` literals |

## New Files

| File | Purpose |
|------|---------|
| `Sources/EnviousWispr/Resources/Localizable.xcstrings` | String catalog for all UI languages |
| `Sources/EnviousWispr/Resources/en.lproj/` | English base strings (auto-generated by Xcode or hand-authored) |
| `Sources/EnviousWispr/Resources/es.lproj/` | Spanish translations |
| `Sources/EnviousWispr/Resources/fr.lproj/` | French translations |
| `Sources/EnviousWispr/Resources/de.lproj/` | German translations |
| `Sources/EnviousWispr/Resources/ja.lproj/` | Japanese translations |
| `Sources/EnviousWispr/Resources/zh-Hans.lproj/` | Simplified Chinese translations |
| `Sources/EnviousWispr/Resources/ko.lproj/` | Korean translations |
| `Sources/EnviousWispr/Resources/ar.lproj/` | Arabic translations (RTL) |

## Implementation Plan

### Step 1: Enable resource bundling in Package.swift

The target currently excludes the Resources directory. Change it to process resources so `.xcstrings` and `.lproj` bundles are compiled into the app:

```swift
// Package.swift — before:
.executableTarget(
    name: "EnviousWispr",
    dependencies: [ "WhisperKit", "FluidAudio", "Sparkle" ],
    path: "Sources/EnviousWispr",
    exclude: ["Resources"]
)

// After:
.executableTarget(
    name: "EnviousWispr",
    dependencies: [ "WhisperKit", "FluidAudio", "Sparkle" ],
    path: "Sources/EnviousWispr",
    resources: [.process("Resources")]
)
```

SPM's `.process("Resources")` compiles `.xcstrings` catalogs and copies `.lproj` directories into the bundle automatically.

### Step 2: Create Localizable.xcstrings catalog

Create `Sources/EnviousWispr/Resources/Localizable.xcstrings` as a JSON-format string catalog. The `.xcstrings` format is the modern replacement for `.strings`/`.stringsdict`, supported from macOS 13+. Since we target macOS 14+, it is safe to use exclusively.

Minimal structure — add one entry per UI string:

```json
{
  "sourceLanguage" : "en",
  "strings" : {
    "Start Recording" : {
      "localizations" : {
        "en" : { "stringUnit" : { "state" : "translated", "value" : "Start Recording" } },
        "es" : { "stringUnit" : { "state" : "translated", "value" : "Iniciar grabación" } },
        "fr" : { "stringUnit" : { "state" : "translated", "value" : "Démarrer l'enregistrement" } },
        "de" : { "stringUnit" : { "state" : "translated", "value" : "Aufnahme starten" } },
        "ja" : { "stringUnit" : { "state" : "translated", "value" : "録音開始" } },
        "zh-Hans" : { "stringUnit" : { "state" : "translated", "value" : "开始录音" } },
        "ko" : { "stringUnit" : { "state" : "translated", "value" : "녹음 시작" } },
        "ar" : { "stringUnit" : { "state" : "translated", "value" : "بدء التسجيل" } }
      }
    },
    "Stop Recording" : { ... },
    "Settings..." : { ... },
    "Open EnviousWispr" : { ... },
    "Quit EnviousWispr" : { ... },
    "Check for Updates\u2026" : { ... }
  },
  "version" : "1.0"
}
```

All SwiftUI `Text("literal")` calls already resolve via `LocalizedStringKey` at compile time — no code change is needed for them as long as the key exists in the catalog.

### Step 3: Fix NSMenuItem titles in AppDelegate.swift

`NSMenuItem(title:)` takes a plain `String`, not a `LocalizedStringKey`. Every menu item title must be wrapped:

```swift
// Before (AppDelegate.swift line 83):
let recordTitle = state == .recording ? "Stop Recording" : "Start Recording"

// After:
let recordTitle = state == .recording
    ? String(localized: "Stop Recording")
    : String(localized: "Start Recording")

// Before (line 92):
let openItem = NSMenuItem(title: "Open EnviousWispr", ...)

// After:
let openItem = NSMenuItem(title: String(localized: "Open EnviousWispr"), ...)

// Similarly for:
// "Settings..."
// "Check for Updates\u2026"
// "Quit EnviousWispr"
// The status line format string:
let statusText = String(localized: "\(state.statusText) — \(backend)")
// Better: use a format key:
let statusText = String(localized: "status-line \(state.statusText) \(backend)",
                        defaultValue: "\(state.statusText) — \(backend)")
```

### Step 4: Fix PipelineState.statusText

`PipelineState` has a `statusText: String` computed property used both in `AppDelegate` (NSMenuItem) and SwiftUI views. The SwiftUI side needs a `LocalizedStringKey` variant; the AppKit side needs a `String`. Add both:

```swift
// In PipelineState (wherever it lives, e.g. Pipeline/PipelineState.swift):
var statusText: String {
    switch self {
    case .idle:         return String(localized: "Idle")
    case .recording:    return String(localized: "Recording")
    case .transcribing: return String(localized: "Transcribing")
    case .polishing:    return String(localized: "Polishing")
    case .complete:     return String(localized: "Complete")
    case .error(let m): return String(localized: "Error: \(m)")
    }
}

// Add a LocalizedStringKey variant for SwiftUI Text() where needed:
var statusKey: LocalizedStringKey {
    switch self {
    case .idle:         return "Idle"
    case .recording:    return "Recording"
    case .transcribing: return "Transcribing"
    case .polishing:    return "Polishing"
    case .complete:     return "Complete"
    case .error(let m): return "Error: \(m)"
    }
}
```

### Step 5: Fix string interpolations in SettingsView

SwiftUI `Text()` wraps string literals as `LocalizedStringKey` but string interpolations produce `String` — they are NOT localized automatically. Find all `Text(String(format:...))` and `Text("\(someValue)")` patterns:

```swift
// Before (SettingsView.swift):
Text(String(format: "%.1fs", appState.vadSilenceTimeout))

// This is numeric formatting, not a UI label — no change needed (not translatable text).

// But any mixed literal+variable UI label must use String(localized:):
// Before:
Text("Larger models produce better transcription but require more download time and memory.")
// This is a plain literal — already works as LocalizedStringKey. Add to catalog and done.

// Before (caption with interpolation):
Text("Recording stops automatically after this duration of silence following speech.")
// Pure literal — fine as-is once key is in catalog.
```

The only real issue is captions that are pure string literals — they already work. Review all files for `Text("\(variable)")` patterns where the text itself is a label; those need `Text(verbatim:)` for dynamic content or separate keys.

### Step 6: RTL support

SwiftUI's layout engine flips leading/trailing automatically for RTL locales. No code changes are needed for most layouts. The only areas needing manual review are:

1. **Custom HStack with explicit left/right alignment** — replace with leading/trailing.
2. **The recording overlay panel** (`RecordingOverlayPanel`) — if it uses absolute frame origins, test in Arabic locale.
3. **The waveform/audio level visualizer** — directional rendering may need mirroring. Apply `.flipsForRightToLeftLayoutDirection(true)` to relevant shapes.

To test RTL locally without changing system language:

```swift
// In EnviousWisprApp.swift, add a debug override:
#if DEBUG
    .environment(\.layoutDirection, .rightToLeft)
#endif
```

### Step 7: Language picker in Settings (optional, Phase 2)

By default, the app follows the system language. For Phase 1, no in-app language picker is needed — users change language via System Settings. A picker can be added later:

```swift
// In GeneralSettingsView, future addition:
Section("Language") {
    Picker("App Language", selection: $appLanguage) {
        Text("System Default").tag("")
        Text("English").tag("en")
        Text("Español").tag("es")
        Text("Français").tag("fr")
        Text("Deutsch").tag("de")
        Text("日本語").tag("ja")
        Text("中文 (简体)").tag("zh-Hans")
        Text("한국어").tag("ko")
        Text("العربية").tag("ar")
    }
}
```

This requires writing `AppleLanguages` to `UserDefaults` and relaunching — non-trivial and deferred.

### String Extraction Checklist

All user-facing string literals to add to `Localizable.xcstrings`:

**AppDelegate.swift (menu items):**
- "Start Recording" / "Stop Recording"
- "Open EnviousWispr"
- "Settings..."
- "Check for Updates\u2026"
- "Quit EnviousWispr"

**SettingsView.swift (section headers and labels):**
- "ASR Backend", "Recording", "Voice Activity Detection", "Behavior", "Performance"
- "Backend", "Mode", "Model Quality"
- "Parakeet v3 (Primary)", "WhisperKit (Fallback)"
- "Push to Talk", "Toggle"
- "Base (Fast, Lower Quality)", "Small (Balanced)", "Large v3 (Best Quality)"
- "Auto-stop on silence", "Silence timeout", "Real-time silence filter"
- "Auto-copy to clipboard"
- "Run Benchmark"
- All description captions

**ShortcutsSettingsView.swift:**
- "Global Hotkey", "Enable global hotkey"
- "Current hotkey:", "Hotkey Reference"
- "Toggle mode:", "Push-to-talk:", "Open window:", "Settings:"
- "Press \u2303Space to toggle recording on/off."
- "Hold \u2325Option to record, release to stop."

**LLMSettingsView.swift:**
- "LLM Provider", "Provider", "Model"
- "None", "OpenAI", "Google Gemini"
- "OpenAI API Key", "Gemini API Key"
- "Save Key", "Clear Key"
- "Validating...", "Valid"

**PermissionsSettingsView.swift:**
- "Microphone", "Accessibility"
- "Microphone access granted", "Microphone access denied"
- "Accessibility access granted", "Accessibility access needed for paste-to-app"
- "Request Access", "Enable"

**TranscriptDetailView.swift:**
- "Copy", "Paste to App", "Enhance", "Delete"
- "Original transcript"
- "Enhanced"

**PipelineState:**
- "Idle", "Recording", "Transcribing", "Polishing", "Complete", "Error"

## Testing Strategy

1. **Build verification:** `swift build` must succeed after changing `exclude` to `resources: [.process("Resources")]`. SPM should compile the `.xcstrings` catalog without error.

2. **Locale simulation:** In System Settings > Language & Region, add Spanish and set it as the primary language. Relaunch the app and verify all menu items and view labels appear in Spanish.

3. **RTL layout test:** Temporarily add `.environment(\.layoutDirection, .rightToLeft)` to the root view. Verify that the main window, settings tabs, and transcript list all mirror correctly.

4. **String completeness:** Run a grep for all `Text("`, `Label("`, `NSMenuItem(title:`, and `String(localized:` calls. Cross-reference against `Localizable.xcstrings` to ensure no key is missing.

5. **Fallback behavior:** Remove a key from one language and verify the app falls back to English rather than showing a key literal.

6. **Bundle verification:** Run `swift build -c release --arch arm64` and inspect `.build/arm64-apple-macosx/release/EnviousWispr_EnviousWispr.bundle` (or the main binary's embedded resources) to confirm `.xcstrings` is present.

## Risks & Considerations

- Large effort: every string in every view must be extracted
- Translation quality: machine translation vs human translators
- Ongoing maintenance: every new feature needs translations
- RTL: some custom layouts may need manual mirroring
- SwiftUI handles much of the heavy lifting but edge cases exist
- The `.xcstrings` format requires `swift-tools-version: 5.9+` for `.process("Resources")` — we are on 6.0, so this is fine
- Changing `exclude` to `resources` may affect how `Info.plist` and `AppIcon.icns` are handled — verify `build-dmg.sh` still finds them at the expected paths under `Sources/EnviousWispr/Resources/`
